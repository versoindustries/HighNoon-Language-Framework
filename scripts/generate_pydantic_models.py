#!/usr/bin/env python3
# scripts/generate_pydantic_models.py
# Copyright 2025 Verso Industries (Author: Michael B. Zimmerman)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Generate Pydantic models from highnoon/config.py at build time.

HIGHNOON_UPGRADE_ROADMAP.md Phase 5.1 - Build-Time Pydantic Generation.

This script parses config.py and generates a Pydantic model class for
use in the WebUI and API validation. It extracts:
- Variable names and types
- Default values
- Comments as Field descriptions

Usage:
    python scripts/generate_pydantic_models.py

Output:
    highnoon/webui/generated_models.py

CI Integration:
    - name: Generate Pydantic models
      run: python scripts/generate_pydantic_models.py
    - name: Check for drift
      run: git diff --exit-code highnoon/webui/generated_models.py
"""

import ast
import re
import sys
from datetime import datetime
from pathlib import Path
from typing import Any

# Add project root to path
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.insert(0, str(PROJECT_ROOT))


def extract_config_vars(config_path: Path) -> list[dict[str, Any]]:
    """Extract typed variables from config.py.

    Args:
        config_path: Path to config.py

    Returns:
        List of dicts with name, type, default, and description
    """
    content = config_path.read_text()
    tree = ast.parse(content)

    # Also parse comments for descriptions
    lines = content.split("\n")
    line_comments: dict[int, str] = {}
    for i, line in enumerate(lines, 1):
        if "#" in line:
            comment = line.split("#", 1)[1].strip()
            if comment and not comment.startswith("="):
                line_comments[i] = comment

    configs = []

    for node in ast.walk(tree):
        if isinstance(node, ast.AnnAssign):
            # Typed variable like: VAR_NAME: type = value
            if isinstance(node.target, ast.Name):
                name = node.target.id
                type_hint = ast.unparse(node.annotation) if node.annotation else "Any"
                default = ast.unparse(node.value) if node.value else "None"

                # Get inline comment
                description = line_comments.get(node.lineno, "")

                # Skip private/internal vars
                if name.startswith("_"):
                    continue

                configs.append(
                    {
                        "name": name,
                        "type": type_hint,
                        "default": default,
                        "description": description,
                        "line": node.lineno,
                    }
                )

    return configs


def python_type_to_pydantic(py_type: str) -> str:
    """Convert Python type hint to Pydantic-compatible type.

    Args:
        py_type: Python type string

    Returns:
        Pydantic-compatible type string
    """
    # Handle common type conversions
    type_map = {
        "bool": "bool",
        "int": "int",
        "float": "float",
        "str": "str",
        "list": "list",
        "dict": "dict",
        "tuple": "tuple",
        "Any": "Any",
        "None": "None",
    }

    # Handle list[int], dict[str, Any], etc.
    if "[" in py_type:
        return py_type

    return type_map.get(py_type, "Any")


def generate_pydantic_model(configs: list[dict[str, Any]]) -> str:
    """Generate Pydantic model code from config vars.

    Args:
        configs: List of config variable dicts

    Returns:
        Python source code for Pydantic model
    """
    header = f'''# highnoon/webui/generated_models.py
# AUTO-GENERATED - DO NOT EDIT MANUALLY
# Generated by scripts/generate_pydantic_models.py
# Generated at: {datetime.utcnow().isoformat()}Z
#
# HIGHNOON_UPGRADE_ROADMAP.md Phase 5.1 - Build-Time Pydantic Generation

"""Pydantic models generated from highnoon/config.py.

These models are used for API validation and WebUI configuration.
Any changes should be made to config.py and this file regenerated.
"""

from typing import Any

from pydantic import BaseModel, Field


class HighNoonConfig(BaseModel):
    """Pydantic model for HighNoon configuration.

    Generated from highnoon/config.py. Contains all configuration
    parameters with types, defaults, and descriptions.
    """
'''

    fields = []
    for cfg in configs:
        field_name = cfg["name"].lower()
        field_type = python_type_to_pydantic(cfg["type"])
        default = cfg["default"]
        description = cfg["description"]

        # Clean up default value for Pydantic
        if default == "True":
            default = "True"
        elif default == "False":
            default = "False"
        elif default == "None":
            default = "None"

        # Build field definition
        if description:
            field_def = f'    {field_name}: {field_type} = Field(default={default}, description="{description}")'
        else:
            field_def = f"    {field_name}: {field_type} = {default}"

        fields.append(field_def)

    # Join all fields
    field_str = "\n".join(fields)

    # Add model config
    footer = '''

    class Config:
        """Pydantic model configuration."""

        extra = "allow"  # Allow extra fields
        validate_assignment = True
'''

    return header + field_str + footer


def main():
    """Generate Pydantic models from config.py."""
    config_path = PROJECT_ROOT / "highnoon" / "config.py"
    output_path = PROJECT_ROOT / "highnoon" / "webui" / "generated_models.py"

    if not config_path.exists():
        print(f"Error: Config file not found at {config_path}")
        sys.exit(1)

    print(f"Reading config from: {config_path}")
    configs = extract_config_vars(config_path)
    print(f"Found {len(configs)} configuration variables")

    # Filter to only include important config groups
    # (skip internal/development vars)
    important_prefixes = [
        "USE_",
        "LITE_",
        "NUM_",
        "MAX_",
        "HD_",
        "QULS_",
        "BARREN_",
        "VQC_",
        "MAMBA",
        "WLAM",
        "TOP_K",
        "ADAPTER",
        "TT_",
        "REASONING",
        "SUPERPOSITION",
    ]

    filtered_configs = [
        cfg
        for cfg in configs
        if any(cfg["name"].startswith(prefix) for prefix in important_prefixes)
    ]

    print(f"Filtered to {len(filtered_configs)} important configuration variables")

    model_code = generate_pydantic_model(filtered_configs)

    print(f"Writing Pydantic model to: {output_path}")
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(model_code)

    print("Done!")


if __name__ == "__main__":
    main()
